#version 460 core
#extension GL_ARB_bindless_texture : require

#define KERNEL_SIZE 64
#define NOISE_SIZE 4

uniform mat4 projMatrix;
uniform mat4 invProjMatrix;
uniform vec3 kernel[KERNEL_SIZE];
layout(bindless_sampler) uniform sampler2D depthTex;

layout(std430, binding = 2) readonly buffer RotationBuffer {
	vec2 samples[];
};

layout(r8, binding = 0) restrict writeonly uniform image2D ssaoImg;

const float radius = 0.5f;

vec3 derivePos(ivec2 texel, float depth) {
	vec4 ndc = vec4(vec2(texel) / vec2(textureSize(depthTex, 0)) * 2.0f - 1.0f, depth, 1.0f);
	vec4 viewSpace = invProjMatrix * ndc;
	return viewSpace.xyz / viewSpace.w;
}

vec3 derivePos(ivec2 texel) {
	float depth = texelFetch(depthTex, texel, 0).r;
	return derivePos(texel, depth);
}

vec3 deriveNormal(vec3 pos, ivec2 texel) {
	float depth = texelFetch(depthTex, texel, 0).r;

	vec4 nearTaps = vec4(
		texelFetch(depthTex, texel + ivec2(-1, 0), 0).r,
		texelFetch(depthTex, texel + ivec2(1, 0), 0).r,
		texelFetch(depthTex, texel + ivec2(0, -1), 0).r,
		texelFetch(depthTex, texel + ivec2(0, 1), 0).r
	);

	vec4 farTaps = vec4(
		texelFetch(depthTex, texel + ivec2(-2, 0), 0).r,
		texelFetch(depthTex, texel + ivec2(2, 0), 0).r,
		texelFetch(depthTex, texel + ivec2(0, -2), 0).r,
		texelFetch(depthTex, texel + ivec2(0, 2), 0).r
	);

	vec4 interpolated = abs(2 * nearTaps - farTaps - pos.z);

	vec3 ddx = interpolated.y > interpolated.x ?
		pos - derivePos(texel + ivec2(-1, 0), nearTaps.x) :
		derivePos(texel + ivec2(1, 0), nearTaps.y) - pos;

	vec3 ddy = interpolated.w > interpolated.z ?
		pos - derivePos(texel + ivec2(0, -1), nearTaps.z) :
		derivePos(texel + ivec2(0, 1), nearTaps.w) - pos;

	return normalize(cross(ddx, ddy));
}

layout (local_size_x = 8, local_size_y = 8) in;
void main() {
	ivec2 texel = ivec2(gl_GlobalInvocationID.xy * 2);
	vec2 viewportSize = vec2(textureSize(depthTex, 0));
	if(texel.x >= viewportSize.x || texel.y >= viewportSize.y) return;

	vec3 pos = derivePos(texel);
	vec3 normal = deriveNormal(pos, texel);

	uvec2 offset = uvec2(mod(gl_GlobalInvocationID.xy, uvec2(NOISE_SIZE)));
	vec3 rotation = vec3(samples[offset.x * NOISE_SIZE + offset.y], 0.0f);
	vec3 tangent = normalize(rotation - normal * dot(rotation, normal));
	vec3 bitangent = cross(normal, tangent);
	mat3 tbn = mat3(tangent, bitangent, normal);

	float occlusion = 0.0f;
	for(int i = 0; i < KERNEL_SIZE; i++) {
		vec3 samplePos = pos + tbn * kernel[i] * radius;
		vec4 samplePosNDC = projMatrix * vec4(samplePos, 1.0f);
		ivec2 sampleTexel = ivec2((samplePosNDC.xy / samplePosNDC.w * 0.5f + 0.5f) * viewportSize);
		float sampleDepth = derivePos(sampleTexel).z;
		float falloff = smoothstep(0.0f, 1.0f, radius / abs(pos.z - sampleDepth));
		occlusion += float(sampleDepth >= samplePos.z) * falloff;
	}

	imageStore(ssaoImg, ivec2(gl_GlobalInvocationID.xy), vec4(1.0f - occlusion / KERNEL_SIZE, 0.0f, 0.0f, 0.0f));
}